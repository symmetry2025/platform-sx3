# Каноничный пайплайн тренажёров (единая архитектура) + Backlog

Дата: 2026-02-05  
Контекст: `projects/symmetry-trainer/trainer-wt/_main`

## 1) Проблема, которую решаем

Сейчас в коде есть несколько “семейств” тренажёров, которые **похожи по UX**, но реализованы разными пайплайнами:

- **Mental Math**: уже переведён на `TrainerFlow` (select → session → result), общий layout + общий result screen.
- **Column**: уже переведён на `TrainerFlow` (presets → session → result), общий result screen, HUD скрыт у внутренних wrappers.
- **Multiplication (таблица)**: больше не отдельный “runner” пайплайн — это Drill‑тренажёр на `TrainerFlow` с фиксированными пресетами (пока прогресс — localStorage).

Цель: **единая каноничная “обёртка”** (пайплайн) для всех тренажёров:

1) Входим в тренажёр  
2) Выбираем уровень (presets) *(99% случаев)*  
3) Опционально открываем **Advanced** и настраиваем параметры *(редко, “продвинутый режим”)*  
4) Попадаем в сессию  
5) Проходим сессию  
6) Попадаем на единый экран успеха/неуспеха  
7) “Ещё раз / Следующий уровень / К выбору уровня” работают одинаково и предсказуемо

## 2) Базовые “виды” тренажёров (чтобы не плодить типы)

Мы фиксируем **не “каждый тренажёр = новый тип”**, а несколько базовых аркетипов:

### 2.1 Drill (карточки)
Единый “движок” сессии: карточка примера + ввод/выбор ответа, таймер (опционально), прогресс, помощник (опционально).  
Отличие между “умножение на 2” и “сложение до 20” — **только в генераторе примеров**, а не в типе тренажёра.

### 2.2 Column (столбики)
Это отдельный UX/логика ввода (клетки, переносы, шаги), но **пайплайн и обёртка те же**: preset select → session → canonical result.

### 2.3 Game modes как надстройка (не отдельный тип)
`accuracy / speed / race` — это режимы/пресеты сессии, применимые к Drill/Column (если нужно).

## 2.4 Термины и границы ответственности (чтобы не было путаницы)

- **Archetype (Drill/Column)**: тип UX/сессии на фронте (как выглядит и как вводится ответ).
- **Backend `kind`** (`/api/progress/record`): текущая серверная классификация прогресса. Сейчас она **не 1:1** с archetype:
  - `kind='mental'` — фактически Drill‑сессия (карточки), но с отдельной моделью прогресса.
  - `kind='column'` — Column‑сессия.
  - `kind='drill'` (потенциально) — общий backend‑kind для будущих Drill‑тренажёров (runner и др.).
- **Preset**: “уровень/режим”, который выбирает пользователь. Preset описывает `SessionConfig`, `successPolicy`, `helper` и `unlockPolicy`.
- **Advanced**: UI для переопределения `SessionConfig` выбранного preset (ручная настройка).

Важное следствие: на первом этапе мы унифицируем **пайплайн и UI**, не обязательно сразу унифицируя backend `kind`.

## 3) Ключевая унификация: Presets + Advanced

### 3.1 Preset — это “уровень” (то, что выбираем в 99% случаев)
Любой уровень/сложность — это `presetId → SessionConfig`.  
Пример:

- Column: `accuracy`, `speed`, `race:1`, `race:2`, `race:3`
- Mental: `accuracy-choice`, `accuracy-input`, `speed`, `race:1..3`
- Runner: `practice:choice`, `practice:manual`, `training:ordered`, и т.д.

### 3.2 Advanced — это “ручная конфигурация пресета”
Advanced **не меняет пайплайн**, это лишь дополнительный UI на экране выбора:

- пользователь выбирает пресет
- нажимает “Расширенные настройки”
- видит форму, предзаполненную значениями выбранного пресета
- меняет параметры и стартует

Важно: Advanced может быть доступен не у всех тренажёров и/или не у всех пресетов.

## 4) Helper (помощник) — фича пресета, а не отдельный тренажёр

Помощник (таблица/подсказки/вспомогательный UI) описывается в конфиге пресета:

- `helper.enabled: boolean`
- `helper.type: 'table' | 'numbers' | ...`
- `helper.params: {...}`

Таким образом:

- Runner остаётся Drill-тренажёром, просто некоторые пресеты включают helper
- в будущем helper можно включать в любых Drill-тренажёрах без “нового типа”

## 5) Критерий успеха — часть пресета (оба варианта)

Требование: критерий успеха может быть

- **процент правильных** (например, `correct/total >= 0.8`)
- **без ошибок** (например, `mistakes === 0`)
- (опционально) смешанный/комбинированный

Это описывается в пресете:

- `successPolicy: { type: 'minAccuracy', min: 0.8 }`
- `successPolicy: { type: 'noMistakes' }`

## 6) Целевая архитектура кода (каноничный пайплайн)

### 6.1 State machine (одинаковая для всех)

`entry → select(preset) → session → result`

Где `select` может показывать:

- только пресеты (стандарт)
- пресеты + кнопку Advanced
- (редко) отдельную форму settings, но через тот же механизм advanced

### 6.2 Контракт “тренажёра” (плагин для пайплайна)

Идея: `TrainerDefinition` описывает, как:

- получить и интерпретировать прогресс (unlock)
- показать список пресетов
- собрать `SessionConfig` из выбранного пресета (и advanced overrides)
- отрендерить сессию
- записать результат и обновить прогресс

Ключ: **пайплайн управляет экранами и кнопками**, тренажёр управляет только доменной логикой.

### 6.3 Инварианты (идемпотентность и консистентность)

Чтобы пайплайн был предсказуемым и не “дёргался”:

- **Retry идемпотентен по конфигу**: “Ещё раз” всегда перезапускает **тот же** `presetId + overrides`, без `window.location.reload()`.
- **Back идемпотентен по прогрессу**: “К выбору уровня” возвращает в select и показывает **актуальные lock/unlock**, не инициируя лишние запросы, если прогресс уже гидратирован.
- **RecordResult устойчив к ретраям**:
  - UI может повторно отправить запись из‑за сети/ретраев — серверная запись прогресса не должна ломаться.
  - Текущее поведение создаёт “immutable attempt” при каждом POST (не идемпотентно по попыткам). Это допустимо как лог, но для чистоты можно добавить `attemptId` и дедуп (см. TRN-014).
- **Hydration**: прогресс гидратируется в `entry` на клиенте, с TTL (уже есть `progressHydration.ts`) — это базовый механизм против SSR mismatch и “мигания” unlock.

### 6.4 Decision log / Open questions

Эта секция фиксирует решения и “неопределённости”, чтобы план оставался идемпотентным (без постоянного пересогласования).

#### Вопрос: уровни всегда линейные (accuracy→speed→race) или иногда просто список без зависимостей?
**Статус**: не решено (в будущем возможны оба варианта).

**Техническое решение**: в модели есть `UnlockPolicy` и per-preset `unlock`, поэтому:

- если уровни независимы: используем `UnlockPolicy: none` (или `custom` с “всё открыто”)
- если строгая прогрессия: используем `UnlockPolicy: linear` (или `custom`) и фиксируем порядок пресетов
- если сложные правила: используем `UnlockPolicy: custom` (функция `isLocked` + reason)

Это позволяет добавлять новые Drill‑тренажёры без переписывания UI выбора пресета.

#### Решение: Helper — часть preset
**Решено**: helper включается/настраивается через preset (и может быть переопределён Advanced).

#### Решение: критерий успеха — часть preset
**Решено**: `successPolicy` хранится в preset; поддерживаем минимум два базовых режима: `minAccuracy` и `noMistakes` (+ композиции `allOf/anyOf` при необходимости).

#### FUTURE (после MVP): Admin Preset Overrides (тюнинг времени/кол-ва/скорости соперника)

**Зачем**: на этапе вывода в прод и редких последующих правках нужен тюнинг параметров пресетов без релиза (например: `timeLimit` / `totalProblems` / `npcSecondsPerProblem`).

**Не-цель**: награды/кристаллы НЕ тюним (экономика фиксирована в коде).

**Идея**: оставить пресеты в коде как baseline, а админ правит только *overrides*, которые накладываются на `defaultConfig`.

**Модель данных (минимальная)**:
- ключ: `(trainerId, presetId)`
- поля: `totalProblems?`, `timeLimit?`, `npcSecondsPerProblem?`
- метаданные: `updatedAt`, `updatedBy`

**API**:
- `GET /api/trainer-presets/overrides?trainerId=...`
  - публично для клиента (это не секреты), с агрессивным кэшированием
  - `Cache-Control: public, max-age=60, stale-while-revalidate=300`
  - ответ: `{ version, overrides: [{ presetId, patch }] }`
- `POST /api/admin/trainer-presets/overrides` (RBAC admin, server-side)
  - валидировать диапазоны (например: problems 5..50, time 15..180, npc 1..20)

**FE интеграция**:
- `TrainerFlow` грузит overrides один раз на экране выбора уровней
- описания/цифры на карточках пресетов показываются уже с учётом overrides
- при `Start` делаем `config = merge(defaultConfig, override)` и фиксируем конфиг на попытку

**Консистентность/аналитика**:
- фактические параметры попытки (problems/time/npc) желательно сохранять вместе с attempt (для корректной аналитики при изменении overrides в будущем).

**Масштабирование**:
- чтение overrides должно быть кэшируемым (TTL), чтобы тысячи пользователей не били БД.

## 7) Встраивание текущих тренажёров (mapping)

### 7.1 Mental Math → DrillDefinition (archetype=Drill, backend kind=mental на первом этапе)
- Presets: `accuracy-choice`, `accuracy-input`, `speed`, `race:1..3`
- Убрать `window.location.reload()` на retry: retry должен перезапускать этот же preset/config.
- Результат: отдавать `SessionResult` в общий result screen.
- Прогресс: уже использует `/api/progress/record` (kind=mental).

### 7.2 Column* → ColumnDefinition
- Presets: `accuracy`, `speed`, `race:1..3`
- `TimedMode`/`RaceMode` должны перестать рендерить “итоговые экраны” сами, а возвращать `SessionResult` наружу (в пайплайн).
  - Либо оставить их как визуальные “wrappers”, но финальный экран результата всегда `TrainerResultScreen`.
- Прогресс: уже `/api/progress/record` (kind=column).

### 7.3 Multiplication Runner → DrillDefinition (archetype=Drill, advanced-first)
- Presets: базовые (каноничные) — “быстрый старт”.
- Advanced: текущие “settings” формы → становятся advanced overrides над выбранным пресетом.
- Helper: становится частью пресета и/или advanced (toggle), но живёт в общем `SessionConfig`.
- Прогресс:
  - Вариант A (рекомендуемый): добавить поддержку “drill” в `/api/progress/record` и хранить unlock/best в БД.
  - Вариант B (временный): только localStorage, но пайплайн и UI уже одинаковые; потом переводим на БД.

## 8) API/DTO правила (важно)

Текущее API `/api/progress/record` поддерживает `kind: 'column' | 'mental'`.

Если добавляем новые kinds (например, `drill`) или расширяем поля, то по правилам проекта:

- любые изменения DTO/контрактов делаем через `packages/shared` (`@smmtry/shared`) и синхронно обновляем FE/BE.

В этом приложении `packages/shared` сейчас не лежит рядом; значит отдельная задача — либо подключить существующий `@smmtry/shared` из монорепы, либо добавить shared package на уровень workspace.

## 9) Backlog Issues (канонично, по шагам)

Ниже — backlog в формате “issue”, можно переносить в трекер 1:1.

### 9.1 Текущий статус (обновлено: 2026-02-06)

- **Готово**: TRN-001, TRN-002, TRN-003, TRN-004, TRN-005, TRN-006, TRN-007, TRN-008, TRN-010, TRN-011, TRN-012, TRN-013, TRN-014
- **Частично (остались доделки)**: TRN-009 (Advanced для Drill/таблицы умножения отложен)
- **Не начато**: —

### TRN-001 — Ввести типы и контракт пайплайна (TrainerFlow types)
**Цель**: зафиксировать единый контракт `TrainerDefinition`, `Preset`, `SessionConfig`, `SessionResult`, `SuccessPolicy`, `HelperConfig`, `UnlockPolicy`.

- Depends on: —
- Scope:
  - добавить типы
  - определить `PresetId` формат и конвенции
  - заложить поддержку: “уровни могут быть списком без зависимости” (через `UnlockPolicy`/`isLocked`)
  - описать унифицированные метрики/бейджи для хедера (чтобы `TrainerGameFrame` мог быть каноничным)
- Acceptance:
  - есть единая типизация для всех тренажёров
  - пресеты поддерживают `successPolicy` и `helper`
  - есть механизм “lock/unlock” без предположения о линейной прогрессии
  - “словарь метрик” покрывает: пример x/y, время, ошибки, прогресс %, звёзды/гонка (опционально)

### TRN-002 — Компонент `TrainerFlow` (state machine + навигация экранов)
**Цель**: единый контейнер, который:

- делает `entry` (hydrate progress)
- рендерит `PresetSelect` (+ Advanced)
- запускает `Session`
- рендерит `TrainerResultScreen`
- реализует каноничные кнопки и поведение

Acceptance:
- есть единый пайплайн для 1+ тренажёров
- retry перезапускает ту же сессию без reload
- “К выбору уровня” возвращает в select и сохраняет прогресс в UI

Depends on: TRN-001, TRN-003, TRN-004

### TRN-003 — Каноничный UI выбора пресета: `PresetSelect`
**Цель**: один компонент списка пресетов + lock state + “Расширенные настройки” (опционально).

Acceptance:
- список пресетов одинаково выглядит у всех
- locked items визуально блокируются, и причина может быть показана (опционально)
- advanced открывается поверх/ниже, не ломая пайплайн

Depends on: TRN-001

### TRN-004 — Каноничный экран результата: `TrainerResultScreen`
**Цель**: один экран успеха/неуспеха для всех тренажёров.

Acceptance:
- показывает заголовок/статус
- показывает метрики (correct/total, mistakes, time, stars/won при наличии)
- кнопки:
  - success: “Следующий уровень”, “К выбору уровня”
  - fail: “Ещё раз”, “К выбору уровня”

Depends on: TRN-001

### TRN-005 — Унифицировать `TrainerGameFrame` как единственную обёртку “сессии”
**Цель**: любая сессия (drill/column) внутри каноничного `TrainerGameFrame`.

Acceptance:
- header/badges/progress имеют единый вид и одинаковые отступы
- контент центрируется по вертикали

Depends on: TRN-001

### TRN-006 — DrillSession engine (общий движок карточек)
**Цель**: общий компонент/хук для Drill:

- генератор примера
- ввод: choice/manual (и расширяемость)
- таймер (опционально)
- уникальность задач (уже есть `prepareUniqueList`)
- helper panel (опционально)

Acceptance:
- можно собрать mental-math и runner на одном движке
- различия только в `ProblemSource` и preset config

Depends on: TRN-001, TRN-002, TRN-005

### TRN-007 — Mental Math миграция на TrainerFlow + общий result screen
**Цель**: mental-math становится первым тренажёром на каноничном пайплайне.

Примечание: на первом шаге допускается использовать существующую реализацию `MentalMathGame` как “чёрный ящик сессии”, просто подключив её к `TrainerFlow`. Переписывать на общий `DrillSession engine` можно позже (TRN-006).

Acceptance:
- нет `window.location.reload()`; retry = перезапуск текущего пресета
- все кнопки результата каноничны
- прогресс как раньше записывается через `/api/progress/record`

### TRN-008 — Column миграция: Timed/Race wrappers возвращают результат в пайплайн
**Цель**: убрать “самостоятельные” result экраны из `TimedMode`/`RaceMode` и из `Column*Game`.

Подход:
- `TimedMode`/`RaceMode` становятся “индикаторами режима” + источником метрик/событий завершения
- финальный экран результата всегда общий

Acceptance:
- column-add/sub/mul/div показывают один и тот же result экран
- “Следующий уровень” работает одинаково везде

Depends on: TRN-002, TRN-004, TRN-005

### TRN-009 — Runner становится DrillDefinition с Advanced
**Цель**: multiplication runner — это Drill с пресетами + advanced overrides.

Acceptance:
- по умолчанию пользователь видит пресеты (как “выбор уровня”)
- advanced открывается из select и позволяет настроить параметры
- helper включается как часть пресета и/или advanced, но хранится в общем `SessionConfig`

Depends on: TRN-002, TRN-003, TRN-005, (желательно) TRN-006

### TRN-010 — Подключение `@smmtry/shared` в этом приложении (для будущих DTO изменений)
**Цель**: техническая подготовка, чтобы любые изменения API/DTO делались канонично через shared.

Acceptance:
- приложение может импортировать нужные DTO/типы из `@smmtry/shared`
- есть понятная инструкция/ссылка “где живёт shared в монорепе” и как синхронизировать FE/BE

### TRN-011 — Прогресс/record для Drill (опционально, но желательно)
**Цель**: вывести runner (и будущие drill тренажёры) в серверный прогресс.

Вариант:
- расширить `/api/progress/record` новым `kind: 'drill'` и моделью прогресса
- DTO через `@smmtry/shared`

Acceptance:
- прогресс и unlock работают кросс-девайс
- trainer list корректно отображает crystals/status для drill тренажёров

Depends on: TRN-010 (shared), TRN-001

### TRN-012 — Реализовать политики unlock (none/linear/custom) поверх единого контракта
**Цель**: закрыть неопределённость “уровни линейные или просто список” чистой реализацией.

Acceptance:
- `UnlockPolicy` реально используется `PresetSelect` (locked/unlocked)
- можно добавить тренажёр со строгой прогрессией без кастомного кода в UI
- можно добавить тренажёр со списком независимых пресетов

Depends on: TRN-001, TRN-003

### TRN-013 — Протянуть каноничные метрики/бейджи во все сессии (adapters)
**Цель**: привести все сессии (mental/runner/column) к единому набору метрик, чтобы header был полностью единым.

Acceptance:
- `TrainerGameFrame` получает данные только из единой модели метрик
- во всех тренажёрах: пример x/y, время, ошибки и прогресс отображаются одинаково (если применимо)

Depends on: TRN-001, TRN-005, TRN-007, TRN-008, TRN-009

### TRN-014 — Идемпотентная запись попыток (attemptId + дедуп на сервере)
**Цель**: сделать `recordResult` устойчивым к сетевым ретраям/двойным кликам без размножения “attempt” в БД.

Идея:
- клиент генерирует `attemptId` (UUID) на старт сессии
- сервер хранит `attemptId` в `trainerAttempt` с unique индексом `(userId, trainerId, attemptId)`
- повторный POST с тем же `attemptId` не создаёт новую попытку, а возвращает тот же прогресс

Acceptance:
- повторный submit результата не создаёт дублей attempt
- прогресс остаётся корректным и монотонным

Depends on: TRN-010 (shared, если меняем DTO), TRN-001

## 10) Порядок внедрения (минимальный риск)

М0: TRN-001..005 (типизация + пайплайн + UI) — **сделано**  
М1: TRN-007 (Mental Math как референс пайплайна, без переписывания движка) — **сделано**  
М2: TRN-008 (Column миграция на общий result) — **сделано**  
М3: TRN-006 + TRN-009 (Drill engine + Runner как advanced drill) — **частично** (Drill engine сделан, Advanced отложен)  
М4: TRN-010(shared) + TRN-011(drill record) + TRN-012..014 (серверный прогресс для drill, unlock политика, метрики, идемпотентность) — **сделано**

## 11) Риски и “острые места”

- **API/DTO**: любые расширения `/api/progress/record` должны идти через `@smmtry/shared`.
- **Постепенная миграция**: важно не ломать текущие тренажёры; мигрируем по одному, сохраняя совместимость.
- **Hydration/localStorage**: уже была проблема mismatch — в новом пайплайне прогресс должен грузиться в `entry` строго на клиенте.
  - Дополнительно: важно, чтобы `entry` не делал двойных запросов (используем TTL и `hydrateProgressFromDb`).

## 12) Definition of Done для “каноничного пайплайна”

Считаем задачу выполненной, когда:

- любой тренажёр = `TrainerDefinition` + общая `TrainerFlow` обёртка
- у всех одинаковые экраны select/session/result
- “Ещё раз / Следующий / К выбору уровня” работают одинаково
- helper и критерии успеха задаются пресетами (и могут быть переопределены advanced)

